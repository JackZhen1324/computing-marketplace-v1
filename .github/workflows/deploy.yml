name: Deploy to Production Server

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  PROJECT_NAME: computing-marketplace-frontend
  DEPLOY_PATH: /opt/computing-marketplace

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Copy files to server
        uses: burnett01/rsync-deployments@6.0.0
        with:
          switches: -avzr --delete
          path: frontend/
          remote_path: ${{ secrets.DEPLOY_PATH || '/opt/computing-marketplace' }}/frontend/
          remote_host: ${{ secrets.SERVER_HOST }}
          remote_user: ${{ secrets.SERVER_USER }}
          remote_port: ${{ secrets.SERVER_PORT || 8222 }}
          remote_key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy to production server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SERVER_PORT || 8222 }}
          timeout: 10m
          script_stop: true
          script: |
            # Set variables
            CONTAINER_NAME="computing-marketplace-frontend"
            DEPLOY_DIR="${{ secrets.DEPLOY_PATH || '/opt/computing-marketplace' }}"
            APP_PORT="${{ secrets.APP_PORT || 3000 }}"

            echo "ğŸš€ Starting deployment..."
            echo "Deploy directory: $DEPLOY_DIR"
            echo "Container name: $CONTAINER_NAME"
            echo "App port: $APP_PORT"

            # Create deploy directory
            sudo mkdir -p $DEPLOY_DIR
            cd $DEPLOY_DIR

            # Check if frontend directory exists and has files
            if [ ! -d "frontend" ] || [ -z "$(ls -A frontend)" ]; then
              echo "âŒ Error: frontend directory is empty or does not exist"
              echo "Please check if rsync copied the files correctly"
              exit 1
            fi

            # Backup current docker-compose.yml if exists
            if [ -f docker-compose.yml ]; then
              cp docker-compose.yml docker-compose.yml.backup-$(date +%Y%m%d-%H%M%S)
            fi

            # Create docker-compose.yml
            cat > docker-compose.yml << 'EOF'
            version: '3.8'

            services:
              frontend:
                build:
                  context: ./frontend
                  dockerfile: Dockerfile
                container_name: computing-marketplace-frontend
                ports:
                  - "3000:8080"
                restart: unless-stopped
                environment:
                  - NODE_ENV=production
                networks:
                  - app-network
                healthcheck:
                  test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:8080/"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 40s

            networks:
              app-network:
                driver: bridge
            EOF

            # Stop and remove old container
            echo "ğŸ›‘ Stopping old container..."
            if docker ps -a | grep -q $CONTAINER_NAME; then
              docker stop $CONTAINER_NAME 2>/dev/null || true
              docker rm $CONTAINER_NAME 2>/dev/null || true
            fi

            # Remove old image to force rebuild
            echo "ğŸ§¹ Removing old image..."
            docker rmi ${DEPLOY_DIR}_frontend 2>/dev/null || true

            # Build and start new container
            echo "ğŸ”¨ Building new image..."
            docker-compose build --no-cache

            echo "ğŸš€ Starting container..."
            docker-compose up -d

            # Wait for container to be healthy
            echo "â³ Waiting for container to be healthy..."
            MAX_WAIT=60
            WAIT_TIME=0
            while [ $WAIT_TIME -lt $MAX_WAIT ]; do
              if docker ps | grep -q $CONTAINER_NAME; then
                if curl -f -s "http://localhost:3000/" > /dev/null 2>&1; then
                  echo "âœ… Container is healthy and responding!"
                  break
                fi
              fi
              echo "   Waiting... ($WAIT_TIME/$MAX_WAIT seconds)"
              sleep 5
              WAIT_TIME=$((WAIT_TIME + 5))
            done

            if [ $WAIT_TIME -ge $MAX_WAIT ]; then
              echo "âš ï¸  Health check timed out"
            fi

            # Show container status
            echo ""
            echo "ğŸ“Š Container status:"
            docker ps -f name=$CONTAINER_NAME

            # Clean up old images
            echo "ğŸ§¹ Cleaning up old images..."
            docker image prune -af --filter "until=72h" 2>/dev/null || true

            echo ""
            echo "âœ… Deployment completed successfully!"
            echo "ğŸŒ Application is running at: http://localhost:$APP_PORT"
